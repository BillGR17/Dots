#!/usr/bin/env zsh

# A script to find processes by name/pattern and interactively select which to kill.
# Searches only for processes owned by the current user.

# Load Zsh's color module for easier and safer color handling
autoload -U colors && colors

# Main function to encapsulate the script's logic
main() {
  # Check if pgrep exists on the system
  if ! command -v pgrep &>/dev/null; then
    print -u2 -- "Error: 'pgrep' command not found. Please install it."
    return 1
  fi

  # Search only for the current user's processes
  local pgrep_output
  pgrep_output=$(pgrep -U $UID "$@" || true)

  # Check if any processes were found
  if [[ -z "$pgrep_output" ]]; then
    print -- "No processes found matching: '$*'"
    return 1
  fi

  print -- "Found your processes matching '$*':"
  print -- "----------------------------------------------------"

  # Run the efficient ps command to get process details
  local ps_output
  ps_output=$(ps -p "${pgrep_output//$'\n'/,}" -o pid=,rss=,command=)

  # Create arrays to hold the PIDs and display them in a numbered list.
  # Using a here-string `<<<` to prevent the while loop from running in a subshell.
  local -a ordered_pids
  local counter=1
  while read -r pid mem_kb cmd_name; do
    ordered_pids+=($pid) # Store PID in order of display
    local mem_mb=$((mem_kb / 1024))
    # Print the numbered, formatted list for the user to see
    printf "[%s%2d%s] [%6d] %5d MB  %s%s%s\n" "$fg[yellow]" "$counter" "$reset_color" "$pid" "$mem_mb" "$fg[green]" "$cmd_name" "$reset_color"
    ((counter++))
  done <<< "$ps_output"

  print -- "----------------------------------------------------"

  # Prompt the user for which processes to kill
  read "reply?Enter numbers to kill (e.g. 1 3), 'a' for all, or 'q' to quit: "

  # Exit if user quit or entered nothing
  if [[ -z "$reply" || "$reply" =~ '^[Qq]$' ]]; then
    print -- "${fg[yellow]}Operation aborted.${reset_color}"
    return 0
  fi

  local -a pids_to_kill
  # If user selected 'a' for all, add all found PIDs to the kill list
  if [[ "$reply" =~ '^[Aa]$' ]]; then
    pids_to_kill=("${ordered_pids[@]}")
  else
    # User entered numbers. Split the input string by spaces into an array.
    local -a selections=("${(@s/ /)reply}")
    for sel in "${selections[@]}"; do
      # Validate that the input is a number and is within the valid range
      if [[ "$sel" =~ '^[0-9]+$' ]] && (( sel > 0 && sel <= ${#ordered_pids[@]} )); then
        pids_to_kill+=(${ordered_pids[$sel]}) # Add the corresponding PID
      else
        print -u2 -- "${fg[red]}Invalid selection: '$sel'. Ignoring.${reset_color}"
      fi
    done
  fi

  # Proceed with killing if at least one valid PID was selected
  if (( ${#pids_to_kill[@]} > 0 )); then
    print -- "Killing selected processes: ${pids_to_kill[*]}"
    kill -9 "${pids_to_kill[@]}" && print -- "${fg[green]}Done.${reset_color}"
  else
    # This message shows if the user's input contained no valid numbers
    print -- "${fg[yellow]}No valid processes selected to kill.${reset_color}"
  fi
}

# --- Script Entry Point ---
if (( $# == 0 )); then
  print -u2 -- "Usage: $(basename "$0") [pgrep_options] <process_name>"
  print -u2 -- "Example: $(basename "$0") -f firefox"
  exit 1
fi

main "$@"
